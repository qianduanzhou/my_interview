# 作用域是什么

## 编译原理

程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

- 分词/词法分析（Tokenizing/Lexing）

  var a = 2;分写成var、a、=、2 、;

- 解析/语法分析（Parsing） 

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。

- 代码生成

  将 AST 转换为可执行代码的过程称被称为代码生成。

## 理解作用域

### 演员表

首先介绍将要参与到对程序 var a = 2; 进行处理的过程中的演员们，这样才能理解接下来将要听到的对话。

- 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程。 

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 

### 编译器

#### LHS(左侧)

赋值操作的目标是谁，如var a = 2;中的a就是LHS引用

#### RHS(右侧)

谁是赋值操作的源头，如console.log(a);中的a就是RHS引用，还有var a = b;中的 b，可以理解为非左侧(LRHS)

### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。

### 异常

非严格模式下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。如a = 2;会在全局作用域中创建一个a的变量。

当引擎执行 RHS 查询时，如console.log('b', b);会抛出ReferenceError异常，因为RHS查询在所有作用域中找不到该变量。

